---
layout: post
title: Moq & AutoFixture & Unit Tests Saga
categories: UnitTests
tags: [moq, autofixture, unittests, C#]
---

[Refer to the previous post on unit testing and Moq]({% post_url 2026-02-28-Mocking %})

### Let’s Revisit Moq

I used a sample `PaymentService.cs` in my previous blog post.

<div class="code-header">PaymentsService.cs</div>

``` csharp
public class PaymentService : IPaymentService
{
    private readonly IValidator<CreatePaymentRequest> _validator;
    private readonly IRepository _repository;
    private readonly IDateTimeWrapper _dateTimeWrapper;
    private readonly IBankProcessor _bankProcessor;
    private readonly ILogger<PaymentService> _logger;
    
    public PaymentService(
        IValidator<CreatePaymentRequest>  validator,
        IRepository repository,
        IDateTimeWrapper dateTimeWrapper,
        IBankProcessor bankProcessor,
        ILogger<PaymentService> logger)
    {
        
        _validator = validator;
        _repository = repository;
        _dateTimeWrapper = dateTimeWrapper;
        _bankProcessor = bankProcessor;
        _logger = logger;
    }

    public async Task<Result<PaymentDto>> CreateAsync(
        CreatePaymentRequest request,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var validationResult = await _validator.
                    ValidateAsync(request, cancellationToken);
            if (!validationResult.IsValid)
                return Result<PaymentDto>
                    .Failure(
                        validationResult.ToString(), 
                        ErrorCode.ValidationError);
            
            var paymentProcessorResult = await ProcessPaymentAsync(
                request,
                cancellationToken);
            if (!paymentProcessorResult.IsSuccess)
            {
                return Result<PaymentDto>
                    .Failure("Failed to process payment", 
                    ErrorCode.Error);
            }
            
            var payment = await StorePaymentAsync(request,
                request.MerchantId,
                paymentProcessorResult.Value,
                cancellationToken);
            
            var maskedCardNumber = $"**** **** **** {request.CardNumber[^4..]}";
            return Result<PaymentDto>
                .Success(new PaymentDto(
                payment.PaymentReference,
                payment.PaymentStatus.ToPaymentStatus(),
                payment.Amount,
                payment.CurrencyCode,
                maskedCardNumber,
                request.ExpiryMonth,
                request.ExpiryYear));
        }
        catch (Exception e)
        {
            _logger.LogError(e, "Error creating payment");
            return Result<PaymentDto>
                .Failure("Failed to create payment", 
                    ErrorCode.Error);
        }
    }
}
```

We are injecting the following interfaces:

```csharp
private readonly IValidator<CreatePaymentRequest> _validator;
private readonly IRepository _repository;
private readonly IDateTimeWrapper _dateTimeWrapper;
private readonly IBankProcessor _bankProcessor;
private readonly ILogger<PaymentService> _logger;
```

In my previous post, I wrote the unit test as shown below.

<div class="code-header">PaymentServiceTest.cs</div>

```csharp
public class PaymentServiceTest
{
    private readonly PaymentService _sut;
    private readonly Mock<IRepository> _mockRepository;
    private readonly Mock<IBankProcessor> _mockBankProcessor;
    private readonly Mock<IValidator<CreatePaymentRequest>> _mockValidator;
    private readonly Mock<IDateTimeWrapper> _mockDateTimeWrapper;
    private readonly Mock<ILogger<PaymentService>> _mockLogger;
    
    public PaymentServiceTest()
    {
        _mockRepository = new Mock<IRepository>();
        _mockBankProcessor = new Mock<IBankProcessor>();
        _mockValidator = new Mock<IValidator<CreatePaymentRequest>>();
        _mockDateTimeWrapper = new Mock<IDateTimeWrapper>();
        _mockLogger = new Mock<ILogger<PaymentService>>();
        _mockDateTimeWrapper
            .Setup(x => x.Now)
            .Returns(DateTimeOffset.UtcNow);

        _sut = new PaymentService(
            _mockValidator.Object,
            _mockRepository.Object,
            _mockDateTimeWrapper.Object,
            _mockBankProcessor.Object,
            _mockLogger.Object);
    }
}
```

The problem with this approach is that we must manually instantiate a `Mock<>` for every interface and pass it to the constructor.  

While this works and is perfectly valid, it becomes verbose and repetitive as the number of dependencies grows.

A better approach is to use **AutoFixture**.

A popular NuGet package is [AutoFixture](https://github.com/AutoFixture/AutoFixture).

---

### AutoFixture Setup

I created a simple helper base class that takes care of the boilerplate required to set up AutoFixture and Moq.

<div class="code-header">ClassContext.cs</div>

```csharp
public class ClassContext<T> where T : class
{
    private readonly Lazy<T> _classFactory;
    private readonly IFixture _classContextFixture;

    public ClassContext()
    {
        _classContextFixture = new Fixture().Customize(new AutoMoqCustomization());
        _classFactory = new Lazy<T>(() => _classContextFixture.Create<T>());
    }

    protected Mock<TEntity> MockOf<TEntity>() where TEntity : class
    {
        return _classContextFixture.Freeze<Mock<TEntity>>();
    }

    protected IFixture Fixture => _classContextFixture;
    protected T Sut => _classFactory.Value;
}
```

We will interact with `Sut`, which represents the **System Under Test**.  

For example:

`public class PaymentServiceTest : ClassContext<PaymentService>`

Here, `PaymentService` is the system under test.

The `Fixture` helps generate fake instances filled with valid random data based on the type.  

For example:

`var dob = Fixture.Create<DateTime>()`

This automatically generates a random `DateTime`. We no longer need to manually create values like:

`var dob = new DateTime(1980, 12, 1)`

One major advantage is **data randomness**.  
Each test run generates new random data, which reduces reliance on hard-coded constants and makes tests more robust.

---

### Let’s Rewrite the Unit Test Using AutoFixture

<div class="code-header">PaymentServiceTest.cs</div>

```csharp
public class PaymentServiceTest : ClassContext<PaymentService>
{
    private readonly Mock<IRepository> _mockRepository;
    private readonly Mock<IBankProcessor> _mockBankProcessor;
    private readonly Mock<IValidator<CreatePaymentRequest>> _mockValidator;
    
    public PaymentServiceTest()
    {
        _mockRepository = MockOf<IRepository>();
        _mockBankProcessor = MockOf<IBankProcessor>();
        _mockValidator = MockOf<IValidator<CreatePaymentRequest>>();
    }

    [Fact]
    public async Task Should_Create_Payment()
    {
        // Arrange
        var authorizationCode = Fixture.Create<string>();
        var year = Random.Shared.Next(DateTime.Now.Year, 2050);
        var month = Random.Shared.Next(1, 13);
        var expiryDate = new DateTime(year, month, 1);
        var request = new CreatePaymentRequest
        {
            Amount = Fixture.Create<int>(),
            CurrencyCode = "GBP",
            CardNumber = Fixture.Create<string>(),
            ExpiryMonth = expiryDate.Month,
            ExpiryYear =expiryDate.Year,
            Cvv = Fixture.Create<string>(),
        };

        _mockValidator
            .Setup(x => x.ValidateAsync(request, It.IsAny<CancellationToken>()))
            .ReturnsAsync(new ValidationResult());
        
        _mockBankProcessor
            .Setup(x => x.ProcessPaymentAsync(It.IsAny<BankPaymentRequest>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new Result<BankPaymentResponse>
            {
                Value = new BankPaymentResponse
                {
                        Authorized = true,
                        AuthroizationCode = authorizationCode
                }
            });

        Payment paymentEntity = null;
        _mockRepository.Setup(x => x.AddAsync(It.IsAny<Payment>(), It.IsAny<CancellationToken>()))
            .Callback((Payment p, CancellationToken ct) =>
            {
                paymentEntity = p;
            });
        
        
        // Act
        var result = await Sut.CreateAsync(request, It.IsAny<CancellationToken>());
        
        // Assert
        result.ShouldNotBeNull();
        result.IsSuccess.ShouldBeTrue();
        result.Value.Id.ShouldNotBeNullOrWhiteSpace();
        result.Value.Status.ToString().ShouldBe("Authorized");
        result.Value.Amount.ShouldBe(request.Amount);
        result.Value.Currency.ShouldBe(request.CurrencyCode);
        result.Value.ExpiryMonth.ShouldBe(request.ExpiryMonth);
        result.Value.ExpiryYear.ShouldBe(request.ExpiryYear);
        
        paymentEntity.ShouldNotBeNull();
        paymentEntity.MerchantId.ShouldBeGreaterThan(0);
        paymentEntity.CurrencyCode.ShouldBe(request.CurrencyCode);
        paymentEntity.Amount.ShouldBe(request.Amount);
        paymentEntity.MerchantId.ShouldBe(request.MerchantId);
        paymentEntity.PaymentReference.ShouldNotBeNullOrWhiteSpace();
        paymentEntity.PaymentStatus.ToString().ShouldBe("Authorized");
        paymentEntity.AuthorizationCode.ShouldBe(authorizationCode);

        _mockRepository.Verify(x => x.SaveChangesAsync(It.IsAny<CancellationToken>()), Times.Once);
    }
}
```

---

### Observation

```csharp
public PaymentServiceTest()
{
    _mockRepository = MockOf<IRepository>();
    _mockBankProcessor = MockOf<IBankProcessor>();
    _mockValidator = MockOf<IValidator<CreatePaymentRequest>>();
}
```

The mock instances are created using the `MockOf<>` helper method.

Another important observation is that we did not explicitly instantiate or configure mocks for the following dependencies:

```csharp
private readonly IDateTimeWrapper _dateTimeWrapper;
private readonly ILogger<PaymentService> _logger;
```

Yet the tests still pass.

This is one of the biggest benefits of using AutoFixture with `AutoMoqCustomization`.

AutoFixture automatically supplies mock implementations for dependencies that are not explicitly configured by the developer.

---

### Data Randomness

```csharp
var authorizationCode = Fixture.Create<string>();
var year = Random.Shared.Next(DateTime.Now.Year, 2050);
var month = Random.Shared.Next(1, 13);
var expiryDate = new DateTime(year, month, 1);
var request = new CreatePaymentRequest
{
    Amount = Fixture.Create<int>(),
    CurrencyCode = "GBP",
    CardNumber = Fixture.Create<string>(),
    ExpiryMonth = expiryDate.Month,
    ExpiryYear =expiryDate.Year,
    Cvv = Fixture.Create<string>(),
};
```

- `Amount = Fixture.Create<int>()` generates a random integer for each run.
- `CardNumber = Fixture.Create<string>()` generates a random string for each run.
- `Cvv = Fixture.Create<string>()` generates a random string for each run.

Alternatively, we can simplify this using the `Build` method, which is cleaner and more expressive:

```csharp
var request = Fixture.Build<CreatePaymentRequest>()
            .With(x => x.CurrencyCode, "GBP")
            .With(x => x.ExpiryMonth, expiryDate.Month)
            .With(x => x.ExpiryYear, expiryDate.Year)
            .Create();
```