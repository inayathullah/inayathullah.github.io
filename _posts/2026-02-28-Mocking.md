---
layout: post
title: Moq & Unit Tests
categories: UnitTests
tags: [moq, automoq, unittests, C#]
---

### What Is Moq and What Problem Does It Solve?

Let's take the following code. This payment service validates input, calls `BankProcessor` to process the payment, and then stores it in the database. It returns `PaymentDto` when successful; otherwise, it returns a failure result with error details.

<div class="code-header">PaymentsService.cs</div>

``` csharp
public class PaymentService : IPaymentService
{
    private readonly IValidator<CreatePaymentRequest> _validator;
    private readonly IRepository _repository;
    private readonly IDateTimeWrapper _dateTimeWrapper;
    private readonly IBankProcessor _bankProcessor;
    private readonly ILogger<PaymentService> _logger;
    
    public PaymentService(
        IValidator<CreatePaymentRequest>  validator,
        IRepository repository,
        IDateTimeWrapper dateTimeWrapper,
        IBankProcessor bankProcessor,
        ILogger<PaymentService> logger)
    {
        
        _validator = validator;
        _repository = repository;
        _dateTimeWrapper = dateTimeWrapper;
        _bankProcessor = bankProcessor;
        _logger = logger;
    }

    public async Task<Result<PaymentDto>> CreateAsync(
        CreatePaymentRequest request,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var validationResult = await _validator.
                    ValidateAsync(request, cancellationToken);
            if (!validationResult.IsValid)
                return Result<PaymentDto>
                    .Failure(
                        validationResult.ToString(), 
                        ErrorCode.ValidationError);
            
            var paymentProcessorResult = await ProcessPaymentAsync(
                request,
                cancellationToken);
            if (!paymentProcessorResult.IsSuccess)
            {
                return Result<PaymentDto>
                    .Failure("Failed to process payment", 
                    ErrorCode.Error);
            }
            
            var payment = await StorePaymentAsync(request,
                request.MerchantId,
                paymentProcessorResult.Value,
                cancellationToken);
            
            var maskedCardNumber = $"**** **** **** {request.CardNumber[^4..]}";
            return Result<PaymentDto>
                .Success(new PaymentDto(
                payment.PaymentReference,
                payment.PaymentStatus.ToPaymentStatus(),
                payment.Amount,
                payment.CurrencyCode,
                maskedCardNumber,
                request.ExpiryMonth,
                request.ExpiryYear));
        }
        catch (Exception e)
        {
            _logger.LogError(e, "Error creating payment");
            return Result<PaymentDto>
                .Failure("Failed to create payment", 
                    ErrorCode.Error);
        }
    }
}
```

We are injecting the following interfaces:

```csharp
private readonly IValidator<CreatePaymentRequest> _validator;
private readonly IRepository _repository;
private readonly IDateTimeWrapper _dateTimeWrapper;
private readonly IBankProcessor _bankProcessor;
private readonly ILogger<PaymentService> _logger;
```

To write a unit test for the following function, we need to pass instances of `IRepository`, `IDateTimeWrapper`, `IBankProcessor`, and `ILogger<PaymentService>`. If we pass real implementations, the test becomes an integration test rather than a unit test, because `IRepository` and `IBankProcessor` will interact with a real database or real processor. Instead, we should pass mocked instances of these interfaces.

```csharp
public async Task<Result<PaymentDto>> CreateAsync(
        CreatePaymentRequest request,
        CancellationToken cancellationToken = default)
```

### Moq to the Rescue
A popular mocking framework for .NET is [Moq](https://github.com/devlooped/moq).

```csharp
// Filename: IDateTimeWrapper.cs
public interface IDateTimeWrapper
{
    public DateTimeOffset Now { get; }
}

// Filename: DateTimeWrapper.cs
// Actual implementation returns current datetime
public class DateTimeWrapper : IDateTimeWrapper
{
    /// <inheritdoc/>
    public DateTimeOffset Now  => DateTimeOffset.Now;
}
```
The real implementation returns the current timestamp, which is hard to test because the value changes every millisecond. To solve this, we can mock this implementation.


```csharp
private readonly Mock<IDateTimeWrapper> _mockDateTimeWrapper = 
    new Mock<IDateTimeWrapper>();

var expectedDateTime = DateTimeOffset.UtcNow;
_mockDateTimeWrapper
    .Setup(x => x.Now)
    .Returns(expectedDateTime);

// Assume sut.Something calls IDateTimeWrapper.Now and returns the current datetime.
var result = sut.Something(request);

// We can now assert that result always matches the mocked datetime.
result.ShouldBe(expectedDateTime);
```

### Let's revisit our PaymentService.cs

The `PaymentService` test can look like this:

<div class="code-header">PaymentServiceTest.cs</div>

```csharp
public class PaymentServiceTest
{
    private readonly PaymentService _sut;
    private readonly Mock<IRepository> _mockRepository;
    private readonly Mock<IBankProcessor> _mockBankProcessor;
    private readonly Mock<IValidator<CreatePaymentRequest>> _mockValidator;
    private readonly Mock<IDateTimeWrapper> _mockDateTimeWrapper;
    private readonly Mock<ILogger<PaymentService>> _mockLogger;
    
    public PaymentServiceTest()
    {
        _mockRepository = new Mock<IRepository>();
        _mockBankProcessor = new Mock<IBankProcessor>();
        _mockValidator = new Mock<IValidator<CreatePaymentRequest>>();
        _mockDateTimeWrapper = new Mock<IDateTimeWrapper>();
        _mockLogger = new Mock<ILogger<PaymentService>>();
        _mockDateTimeWrapper
            .Setup(x => x.Now)
            .Returns(DateTimeOffset.UtcNow);

        _sut = new PaymentService(
            _mockValidator.Object,
            _mockRepository.Object,
            _mockDateTimeWrapper.Object,
            _mockBankProcessor.Object,
            _mockLogger.Object);
    }

    [Fact]
    public async Task Should_Create_Payment()
    {
        // Arrange
        var request = new CreatePaymentRequest
        {
            Amount = 100,
            CurrencyCode = "GBP",
            CardNumber = "4242424242424242",
            ExpiryMonth = 12,
            ExpiryYear = 2029,
            Cvv = "123",
        };

        _mockValidator
            .Setup(x => x.ValidateAsync(
                    request,
                    It.IsAny<CancellationToken>()))
            .ReturnsAsync(new ValidationResult());
        
        _mockBankProcessor
            .Setup(x => x.ProcessPaymentAsync(
                It.IsAny<BankPaymentRequest>(),
                It.IsAny<CancellationToken>()))
            .ReturnsAsync(new Result<BankPaymentResponse>
            {
                IsSuccess = true,
                Value = new BankPaymentResponse
                {
                        Authorized = true,
                        AuthorizationCode = "auth_123"
                }
            });

        Payment paymentEntity = null;
        _mockRepository
            .Setup(x => x.AddAsync(
                    It.IsAny<Payment>(),
                    It.IsAny<CancellationToken>()))
            .Callback((Payment p, CancellationToken ct) =>
            {
                paymentEntity = p;
            });
        
        
        // Act
        var result = await _sut
                .CreateAsync(
                    request,
                    CancellationToken.None);
        
        // Assert
        result.ShouldNotBeNull();
        result.IsSuccess.ShouldBeTrue();
        result.Value.Id.ShouldNotBeNullOrWhiteSpace();
        result.Value.Status.ToString().ShouldBe("Authorized");
        result.Value.Amount.ShouldBe(request.Amount);
        result.Value.Currency.ShouldBe(request.CurrencyCode);
        result.Value.CardNumber.ShouldBe("**** **** **** 4242");
        result.Value.ExpiryMonth.ShouldBe(request.ExpiryMonth);
        result.Value.ExpiryYear.ShouldBe(request.ExpiryYear);
        
        paymentEntity.ShouldNotBeNull();
        paymentEntity.MerchantId.ShouldBe(request.MerchantId);
        paymentEntity.CurrencyCode.ShouldBe(request.CurrencyCode);
        paymentEntity.Amount.ShouldBe(request.Amount);
        paymentEntity.PaymentReference.ShouldNotBeNullOrWhiteSpace();
        paymentEntity.PaymentStatus.ToString().ShouldBe("Authorized");
        paymentEntity.AuthorizationCode.ShouldBe("auth_123");

        _mockRepository
            .Verify(x => x.SaveChangesAsync(
                It.IsAny<CancellationToken>()),
                Times.Once);
    }
}
```

### Some interesting observations

The objective of this setup is to ensure the validator returns a valid result, meaning no validation errors.
```csharp
_mockValidator
            .Setup(x => x.ValidateAsync(
                    request,
                    It.IsAny<CancellationToken>()))
            .ReturnsAsync(new ValidationResult());
```

This setup adds a callback hook. When `AddAsync` is called, the `Payment` object passed into it is captured so we can inspect it. This helps verify that properties are mapped correctly and values are assigned to the right fields.
```csharp
Payment paymentEntity = null;
        _mockRepository
            .Setup(x => x.AddAsync(
                    It.IsAny<Payment>(),
                    It.IsAny<CancellationToken>()))
            .Callback((Payment p, CancellationToken ct) =>
            {
                paymentEntity = p;
            });
```

This `Verify` setup checks whether `SaveChangesAsync` was called. It helps confirm that important methods are invoked. If this call is missing in the actual code, the test fails.
```csharp
_mockRepository
            .Verify(x => x.SaveChangesAsync(
                It.IsAny<CancellationToken>()),
                Times.Once);
```

### Moq
- We can create mock objects for dependencies.
- `Setup` is used to define method behavior.
- `Callback` is useful for capturing incoming parameters and inspecting mapped values.
- `Verify` is used to check whether expected methods were called.
- `It.IsAny<int>()` matches any integer input.
- `It.Is<int>(x => x == 5)` matches only the exact input `5` (strict check).
